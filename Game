
import java.awt.Point;
import java.math.BigInteger;
import java.util.ArrayList;


/**
 *
 * @author Zachary Hoad
 */
public class Game {
    
    private Map map;
    private ArrayList<Ant> ants;
    private ArrayList<Instruction> redBrain;
    private ArrayList<Instruction> blackBrain;
    private Statistics statistics;
    
    public Game(Map map, ArrayList<Ant> ants, ArrayList<Instruction> redBrain, ArrayList<Instruction> blackBrain){
        this.map=map;
        this.ants=ants;
        this.redBrain=redBrain;
        this.blackBrain=blackBrain;
        statistics=new Statistics();
        initialiseRandomint(new BigInteger(""+System.currentTimeMillis()));
    }
    
    public Game swapSides(){
        
    }
    
    public Statistics getStatistics(){
        
    }


    private void step(int id){
        if (antIsAlive(id)){
            Point point = findAnt(id);
            Ant a = antAt(point);
            if (resting(a)>0){
                setResting(a, resting(a)-1);
            } else {
                Instruction i = getInstruction(colour(a), state(a));
                if(i instanceof Sense){
                    Sense s =(Sense)i;
                    Point pp=sensedCell(point, direction(a), s.sensedir);
                    if (cellMatches(pp, s.cond, colour(a))){
                        setState(a, s.st1);
                    } else {
                        setState(a, s.st2);
                    }
                }
                if (i instanceof Mark){
                    Mark m = (Mark)i;
                    setMarkerAt(point, colour(a), m.i);
                    setState(a, m.st);
                }
                if (i instanceof Unmark){
                    Unmark u =(Unmark)i;
                    clearMarkerAt(point, colour(a), u.i);
                    setState(a, u.st);
                }
                if (i instanceof PickUp){
                    PickUp p = (PickUp)i;
                    if (hasFood(a)||foodAt(point)==0){
                        setState(a, p.st2);
                    } else {
                        setFoodAt(point, foodAt(point)-1);
                        setHasFood(a, true);
                        setState(a, p.st1);
                    }
                }
                if (i instanceof Drop){
                    Drop d = (Drop)i;
                    if (hasFood(a)){
                        setFoodAt(point, foodAt(point)+1);
                        setHasFood(a, false);
                    }
                    setState(a, d.st);
                }
                if (i instanceof Turn){
                    Turn t = (Turn)i;
                    setDirection(a, turn(t.lr, direction(a)));
                    setState(a, t.st);
                }
                if (i instanceof Move){
                    Move m = (Move)i;
                    Point newp = adjacentCell(point, direction(a));
                    if (rocky(newp)||someAntIsAt(newp)){
                        setState(a, m.st2);
                    } else {
                        clearAntAt(point);
                        setAntAt(newp, a);
                        setState(a, m.st1);
                        setResting(a, 14);
                        checkForSurroundedAnts(newp);
                    }
                }
                if (i instanceof Flip){
                    Flip f =(Flip)i;
                    if (randomint(f.n)==0){
                        setState(a, f.st1);
                    } else {
                        setState(a, f.st2);
                    }
                }
            }
        }
    }
    
    private int turn(leftOrRight lr, int dir){
        if (lr==leftOrRight.LEFT){
            return (dir+5)%6;
        }
        if (lr==leftOrRight.RIGHT){
            return(dir+1)%6;
        }
        return -1; //Shouldn't happen
    }
    
    private Point sensedCell(Point p, int d, Direction sd){
        if (sd==Direction.HERE){
            return p;
        }
        if (sd==Direction.AHEAD){
            return adjacentCell(p, d);
        }
        if (sd==Direction.LEFTAHEAD){
            return adjacentCell(p, turn(leftOrRight.LEFT, d));
        }
        if (sd==Direction.RIGHTAHEAD){
            return adjacentCell(p, turn(leftOrRight.RIGHT, d));
        }
        return null;
    }
    
    private Point adjacentCell(Point p, int d){
        switch (d){
          case 0: return new Point(p.x+1, p.y);
          case 1: if (even(p.y)){ return new Point(p.x, p.y+1);} else {return new Point(p.x+1, p.y+1);}
          case 2: if (even(p.y)) {return new Point(p.x-1, p.y+1); } else { return new Point(p.x, p.y+1);}
          case 3: return new Point(p.x-1, p.y);
          case 4: if (even(p.y)) { return new Point(p.x-1, p.y-1); } else { return new Point(p.x, p.y-1); }
          case 5: if (even(p.y)) { return new Point(p.x, p.y-1); } else { return new Point(p.x+1, p.y-1); }
        }
        return null;
    }
    
    private boolean even(int i){
        return i%2==0;
    }
    
    public enum Colour{
        RED, BLACK
    }
    
    private Colour otherColour(Colour c){
        if (c==Colour.BLACK){
            return Colour.RED;
        }
        return Colour.BLACK;
    }
    
    private boolean rocky(Point p){
        return map.getCell(p).isRocky();
    }
    
    private int foodAt(Point p){
        return map.getCell(p).hasFood();
    }
    
    private void setFoodAt(Point p, int f){
        map.getCell(p).setHasFood(f);
    }
    
    private boolean anthillAt(Point p, Colour c){
        return map.getCell(p).getAnthill(c);
    }

    private void setMarkerAt(Point p, Colour c, int i){
        map.getCell(p).setMarker(i, true, c);
    }
    
    private void clearMarkerAt (Point p, Colour c, int i){
        map.getCell(p).setMarker(i, false, c);
    }
    
    private boolean checkMarkerAt(Point p, Colour c, int i){
        return map.getCell(p).getMarker(i, c);
    }
    
    private boolean checkAnyMarker(Point p, Colour c){
        boolean[] markers=map.getCell(p).getMarkers(c);
        for (int i=0; i<markers.length; i++){
            if (markers[i]){
                return true;
            }
        }
        return false;
    }
    
    
    private boolean cellMatches(Point p, Condition cond, Colour c){
        if(cond==Condition.ROCK){
            return rocky(p);
        }
        if(cond==Condition.FRIEND){
            //Need ants implemented to do
            //some_ant_is_at(p) &&
            //color(ant_at(p)) = c
        }
        if(cond==Condition.FOE){
            //Need ants implemented to do
            //some_ant_is_at(p) &&
            //color(ant_at(p)) <> c
        }
        if(cond==Condition.FRIENDWITHFOOD){
            //Need ants implemented to do
            //some_ant_is_at(p) &&
            //color(ant_at(p)) = c &&
            //has_food(ant_at(p))
        }
        if(cond==Condition.FOEWITHFOOD){
            //Need ants implemented to do
            //some_ant_is_at(p) &&
            //color(ant_at(p)) <> c &&
            //has_food(ant_at(p))
        }
        if(cond==Condition.FOOD){
            return foodAt(p)>0;
        }
        if(cond==Condition.MARKER){
            return checkMarkerAt(p, c, cond.markerNum);
        }
        if(cond==Condition.FOEMARKER){
            return checkAnyMarker(p, otherColour(c));
        }
        if(cond==Condition.HOME){
            return anthillAt(p, c);
        }
        if(cond==Condition.FOEHOME){
            return anthillAt(p, otherColour(c));
        }
        return false;
    }
    
    private Instruction getInstruction(Colour c, int s){
        //Need ants to do this
    }
    
    private Colour colour(Ant a){
        //Need ants to do this
    }
    
    private int adjacentAnts (Point p, Colour c){
        int n=0;
        for (int d=0; d<=5; d++){
            Point cell=adjacentCell(p, d);
            if (someAntIsAt(cell)&&colour(antAt(cell))==c){
                n++;
            }
        }
        return n;
    }
    
    private void checkForSurroundedAntAt(Point p){
        if (someAntIsAt(p)){
            Ant a = antAt(p);
            if (adjacentAnts(p, otherColour(colour(a))>=5)){
                if (hasFood(a)){
                    setFoodAt(p, (foodAt(p)+1));
                }
                killAntAt(p);
                setFoodAt(p, (foodAt(p)+3));
            }
        }
    }
    
    private void checkForSurroundedAnts(Point p){
        checkForSurroundedAntAt(p);
        for (int d=0; d<=5; d++){
            checkForSurroundedAntAt(adjacentCell(p, d));
        }
    }
    
    private ArrayList<BigInteger> randomintS=new ArrayList();
    
    //Probably initialise with current system time
    private void initialiseRandomint(BigInteger seed){
        for (int i=0; i<4; i++){
            randomintS.add(BigInteger.ZERO);
        }
        randomintS.set(3, seed);
        for (int i=2; i>=0; i--){
            BigInteger news=randomintS.get(i+1);
            news=news.multiply(new BigInteger("22695477"));
            news=news.add(BigInteger.ONE);
            randomintS.set(i, news);
        }
    }
    
    private int randomint(int n){
        randomintS.remove(3);
        BigInteger news=randomintS.get(0);
        news=news.multiply(new BigInteger("22695477"));
        news=news.add(BigInteger.ONE);
        randomintS.add(0, news);
        news=news.divide(new BigInteger("65536"));
        news=news.mod(new BigInteger("16384"));
        news=news.mod(new BigInteger(""+n));
        return news.intValue();
    }
    
    private int state(Ant a){
        //Need ants to do
    }
    
    private int resting(Ant a){
        //Need ants to do
    }
    
    private int direction(Ant a){
        //Need ants to do
    }
    
    private boolean hasFood(Ant a){
        //Need ants to do
    }
    
    private void setState(Ant a, int s){
        //Need ants to do
    }
    
    private void setResting(Ant a, int s){
        //Need ants to do
    }
    
    private void setDirection(Ant a, int d){
        //Need ants to do
    }
    
    private void setHasFood(Ant a, boolean b){
        //Need ants to do
    }
    
    private boolean someAntIsAt(Point p){
        //Need ants to do
    }
    
    private Ant antAt(Point p){
        //Need ants to do
    }
    
    private void setAntAt(Point p, Ant a){
        //Need ants to do
    }
    
    private void clearAntAt(Point p){
        //Need ants to do
    }
    
    private boolean antIsAlive(int id){
        //Need ants to do
    }
    
    private Point findAnt(int id){
        //Need ants to do
    }
    
    private void killAntAt(Point p){
        //Need ants to do
    }
    
    
    
    
    
}
